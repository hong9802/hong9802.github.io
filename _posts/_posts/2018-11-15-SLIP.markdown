---
layout: post
title:  "SLIP에 대해 알아보자!"
date:   2018-11-15 22:22:10 +0700
categories: MeuWorks
---

## SLIP란?
SLIP는 Serial Line Internet Protocol의 약자로, OSI 7 Layer 중 2게층(Data-Link Layer)에 사용되는 프로토콜입니다.<br>
SLIP에서 에러체크하는 기능이 없어서 이를 발전시킨 CSLIP라는 프로토콜도 있습니다.(CRC기능이 추가됨)<br>
아쉽게도 SLIP에 추가기능, 압축, 보안 관련 문제로 인하여 PPP(Point to Point Protocol)이 대신 사용되는 것으로 알고 있습니다.
<b>SLIP는 [RFC 1055](https://tools.ietf.org/html/rfc1055)에 정의되어 있습니다.

## SLIP Framing/DeFraming
SLIP는 특수한 값이 있습니다.(END 등...) 관련 내용은 [wikipedia](https://en.wikipedia.org/wiki/Serial_Line_Internet_Protocol)을 참고해주시기 바랍니다.
<br>
관련 내용은 [tcpip guide](http://www.tcpipguide.com/free/t_SerialLineInternetProtocolSLIP-2.htm)를 참조했습니다.
### 1. Framing
SLIP에서 Datagram의 시작과 끝을 나타내는 END는 정수로 192, 16진수로는 C0<sub>16</sub>입니다. 만약 Datagram내에 시작과 끝부분이 아니지만, 데이터의 값이 C0<sub>16</sub>이면, DeFraming과정에서 끊어질 수 있습니다.<br> Framing과정에서는 이런 일을 방지하기 위해, 특정 값을 일부러 치환합니다.<br>
대표적으로 C0<sub>16</sub>를 (DB<sub>16</sub>, DC<sub>16</sub>)으로 치환합니다.

### 2. DeFraming
앞에 있는 C0<sub>16</sub>을 먼저 찾고, 뒤에 있는 C0<sub>16</sub>을 찾으면 종료합니다.<br>
앞에서 한 과정을 거꾸로 하면 됩니다.
<br>예를 들어 DB<sub>16</sub>, DC<sub>16</sub>가 연속적으로 있을 때는 이를 C0<sub>16</sub>로 치환하면 됩니다.

## [코드로 나타내기!](https://bitbucket.org/hong9802/slip_java/src/master/)
* 본 코드는 Java를 이용하여 만들었으며 실제로는 byte를 이용해서 해야 되지만, 좀 더 편히 하기 위해 int의 배열을 사용하였습니다.(byte가 미리 계산되어 들어왔다고 가정)
* 본 코드는 [RFC 1055](https://tools.ietf.org/html/rfc1055)를 참조하였습니다.
* 본 코드에서는 통신이 지원안됩니다. Framing과 DeFraming이 되는 과정만 나타낸 것입니다.

#### Framing부분!

```JAVA
    /*
    Framing부분! framingIndex함수는 dataBuffer배열 사이즈크기를 계산히는 함수 입니다.
    */
    public int[] framing(int[] byteList)
    {
        int count = 1;
        int[] dataBuffer = new int[framingIndex(byteList)];
        dataBuffer[0] = SLIP_END;
        for(int i: byteList)
        {
            if(i == SLIP_END)
            {
                dataBuffer[count] = SLIP_ESC;
                dataBuffer[count+1] = SLIP_ESC_END;
                count+=2;
            }
            else if(i == SLIP_ESC)
            {
                dataBuffer[count] = SLIP_ESC;
                dataBuffer[count+1] = SLIP_ESC_ESC;
                count+=2;
            }
            else
            {
                dataBuffer[count] = i;
                count++;
            }
        }
        dataBuffer[count] = SLIP_END;
        return dataBuffer;
    }

```

#### DeFraming부분!

```JAVA
    /*
    DeFraming부분! deframingIndex함수는 dataBuffer배열 사이즈크기를 계산히는 함수 입니다.
    */
    public int[] deFraming(int[] byteList)
    {
        int[] dataBuffer = new int[deframingIndex(byteList)];
        for(int i = 0, count = 0; i < byteList.length; i++)
        {
            if(i == 0) {
                continue;
            }
            else if(byteList[i] == SLIP_END)
            {
                return dataBuffer;
            }
            else if(byteList[i] == SLIP_ESC)
            {
                if(byteList[i+1] == SLIP_ESC_END)
                {
                    dataBuffer[count] = SLIP_END; i++; count++;
                }
                else if(byteList[i+1] == SLIP_ESC_ESC)
                {
                    dataBuffer[count] = SLIP_ESC; i++; count++;
                }
            }
            else
            {
                dataBuffer[count] = byteList[i];
                count++;
            }
        }
        return dataBuffer;
    }

```

<b>오타나 잘못된 부분이 있으면 지적 부탁드립니다. 읽어주셔서 감사합니다.</b>
